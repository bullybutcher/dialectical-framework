<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Dialectical Wheel</title>
    <style>
        
        body {
            margin: 0;
            padding: 0;
            background: #f7f7f7;
            font-family: 'Arial Rounded MT Bold', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .wheel-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }

        .wheel-svg {
            max-width: 90vmin;
            max-height: 90vmin;
            width: 100%;
            height: auto;
        }

        .record {
            cursor: grab;
            touch-action: none;
        }

        .record:active {
            cursor: grabbing;
        }

        .clickable-slice {
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            cursor: pointer;
            fill: transparent;
            stroke: transparent;
            stroke-width: 2;
        }

        .clickable-slice:hover {
            stroke: rgba(0, 116, 217, 0.3);
            fill: rgba(0, 116, 217, 0.1);
        }

        .slice-boundary {
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #333;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.9);
            padding: 12px;
            border-radius: 8px;
            pointer-events: none;
        }

        .reset-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #0074d9;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }

        .reset-btn:hover {
            background: #005bb5;
        }
    
    </style>
</head>
<body>
    <div class="wheel-container">
        <div class="controls">
            Drag to rotate â€¢ Click/tap slices to enlarge
        </div>
        <button class="reset-btn" onclick="resetSlices()">Reset</button>

        <svg class="wheel-svg" viewBox="0 0 400 400" xmlns="http://www.w3.org/2000/svg">
            <g class="record">
                <defs>
<path id="arc0" d="M 260.0,200.0 A 60.0,60.0 0 0,1 170.0,251.96152422706632" fill="none"/>
<path id="arc1" d="M 295.0,200.0 A 94.99999999999999,94.99999999999999 0 0,1 152.50000000000003,282.2724133595217" fill="none"/>
<path id="arc2" d="M 330.0,200.0 A 129.99999999999997,129.99999999999997 0 0,1 135.00000000000006,312.583302491977" fill="none"/>
<path id="arc3" d="M 170.0,251.96152422706632 A 60.0,60.0 0 0,1 169.99999999999997,148.03847577293368" fill="none"/>
<path id="arc4" d="M 152.50000000000003,282.2724133595217 A 94.99999999999999,94.99999999999999 0 0,1 152.49999999999997,117.72758664047836" fill="none"/>
<path id="arc5" d="M 135.00000000000006,312.583302491977 A 129.99999999999997,129.99999999999997 0 0,1 134.99999999999994,87.41669750802303" fill="none"/>
<path id="arc6" d="M 169.99999999999997,148.03847577293368 A 60.0,60.0 0 0,1 260.0,199.99999999999997" fill="none"/>
<path id="arc7" d="M 152.49999999999997,117.72758664047836 A 94.99999999999999,94.99999999999999 0 0,1 295.0,199.99999999999997" fill="none"/>
<path id="arc8" d="M 134.99999999999994,87.41669750802303 A 129.99999999999997,129.99999999999997 0 0,1 330.0,199.99999999999997" fill="none"/>
                </defs>
                <circle cx="200" cy="200" r="149.99999999999997" fill="#C6E5B3"/>
<circle cx="200" cy="200" r="114.99999999999999" fill="#FFFFFF"/>
<circle cx="200" cy="200" r="80.0" fill="#F9C6CC"/>
<g id="clickable-slices">
<path class="clickable-slice" data-slice="0" d="M 200,200 L 350.0,200.0 A 150,150 0 0,1 125.00000000000003,329.9038105676658 Z"/>
<path class="clickable-slice" data-slice="1" d="M 200,200 L 125.00000000000003,329.9038105676658 A 150,150 0 0,1 124.99999999999993,70.09618943233426 Z"/>
<path class="clickable-slice" data-slice="2" d="M 200,200 L 124.99999999999993,70.09618943233426 A 150,150 0 0,1 350.0,199.99999999999997 Z"/>
</g>
<circle cx="200" cy="200" r="30.0" fill="#FFFF99"/>
<text x="200" y="200" font-size="16" font-weight="bold" text-anchor="middle" alignment-baseline="middle">Core</text>
<text font-size="12" fill="green"><textPath href="#arc0" startOffset="50%" text-anchor="middle">Family unity</textPath></text>
<text font-size="11" fill="black"><textPath href="#arc1" startOffset="50%" text-anchor="middle">Buy a house</textPath></text>
<text font-size="10" fill="red"><textPath href="#arc2" startOffset="50%" text-anchor="middle">Burden</textPath></text>
<text font-size="12" fill="green"><textPath href="#arc3" startOffset="50%" text-anchor="middle">Clarity, relief</textPath></text>
<text font-size="11" fill="black"><textPath href="#arc4" startOffset="50%" text-anchor="middle">Don't buy</textPath></text>
<text font-size="10" fill="red"><textPath href="#arc5" startOffset="50%" text-anchor="middle">Separation</textPath></text>
<text font-size="12" fill="green"><textPath href="#arc6" startOffset="50%" text-anchor="middle">Liberation</textPath></text>
<text font-size="11" fill="black"><textPath href="#arc7" startOffset="50%" text-anchor="middle">Be homeless</textPath></text>
<text font-size="10" fill="red"><textPath href="#arc8" startOffset="50%" text-anchor="middle">Discomfort</textPath></text>
<g id="slice-boundaries">
<line class="slice-boundary" x1="200" y1="200" x2="350.0" y2="200.0" stroke="#888" stroke-width="1"/>
<line class="slice-boundary" x1="200" y1="200" x2="125.00000000000003" y2="329.9038105676658" stroke="#888" stroke-width="1"/>
<line class="slice-boundary" x1="200" y1="200" x2="124.99999999999993" y2="70.09618943233426" stroke="#888" stroke-width="1"/>
</g>
<path d="M 65.00000000000003,200.00000000000003 Q 102.28427945724303,253.66418792237417 232.5,256.29165124598853" stroke="blue" stroke-width="2" fill="none"/>
<path d="M 232.5,256.29165124598853 L 223.74064006692424,261.1159246174743 L 223.94237673895464,251.11795970879626 Z" fill="blue"/>
<path d="M 135.0,200.0 Q 202.3833102571404,311.4563903003155 267.5,316.91342951089916" stroke="purple" stroke-width="2" fill="none"/>
<path d="M 267.5,316.91342951089916 L 258.4524413666645,321.17273494445953 L 259.2875539753919,311.20766660898164 Z" fill="purple"/>
            </g>
        </svg>
    </div>

    <script>
        
        class DialecticalWheel {
            constructor() {
                this.sliceCount = 3;
                this.centerX = 200;
                this.centerY = 200;
                this.radius = 150;
                this.sliceAngles = Array(3).fill(120.0);

                this.setupSliceInteraction();
                this.setupRotation();
            }

            setupSliceInteraction() {
                const clickableSlices = document.querySelectorAll('.clickable-slice');
                clickableSlices.forEach((slice, index) => {
                    // Desktop click
                    slice.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.enlargeSlice(index);
                    });

                    // Mobile touch handling
                    let touchStartTime = 0;
                    let touchStartPos = null;

                    slice.addEventListener('touchstart', (e) => {
                        e.stopPropagation();
                        touchStartTime = Date.now();
                        const touch = e.touches[0];
                        touchStartPos = { x: touch.clientX, y: touch.clientY };
                    });

                    slice.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        e.stopPropagation();

                        const touchDuration = Date.now() - touchStartTime;
                        const touch = e.changedTouches[0];
                        const touchEndPos = { x: touch.clientX, y: touch.clientY };

                        const distance = Math.sqrt(
                            Math.pow(touchEndPos.x - touchStartPos.x, 2) + 
                            Math.pow(touchEndPos.y - touchStartPos.y, 2)
                        );

                        if (touchDuration < 300 && distance < 20) {
                            this.enlargeSlice(index);
                        }
                    });
                });
            }

            enlargeSlice(targetIndex) {
                const enlargeAmount = 45;
                const totalReduction = enlargeAmount;
                const reductionPerNeighbor = totalReduction / (this.sliceCount - 1);

                this.sliceAngles[targetIndex] = Math.min(
                    this.sliceAngles[targetIndex] + enlargeAmount,
                    150
                );

                for (let i = 0; i < this.sliceCount; i++) {
                    if (i !== targetIndex) {
                        this.sliceAngles[i] = Math.max(
                            this.sliceAngles[i] - reductionPerNeighbor,
                            15
                        );
                    }
                }

                this.normalizeAngles();
                this.updateAllSlices();
            }

            normalizeAngles() {
                const total = this.sliceAngles.reduce((sum, angle) => sum + angle, 0);
                const factor = 360 / total;
                this.sliceAngles = this.sliceAngles.map(angle => angle * factor);
            }

            updateAllSlices() {
                this.updateClickableSlices();
                this.updateSliceBoundaries();
                this.updateArcPaths();
            }

            updateClickableSlices() {
                const clickableSlices = document.querySelectorAll('.clickable-slice');
                let currentAngle = 0;

                clickableSlices.forEach((slice, index) => {
                    const startAngle = currentAngle;
                    const endAngle = currentAngle + this.sliceAngles[index];

                    const pathData = this.createSlicePath(startAngle, endAngle);
                    slice.setAttribute('d', pathData);

                    currentAngle += this.sliceAngles[index];
                });
            }

            updateSliceBoundaries() {
                const boundaries = document.querySelectorAll('.slice-boundary');
                let currentAngle = 0;

                boundaries.forEach((line, index) => {
                    const angleRad = (currentAngle * Math.PI) / 180;
                    const x2 = this.centerX + this.radius * Math.cos(angleRad);
                    const y2 = this.centerY + this.radius * Math.sin(angleRad);

                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);

                    currentAngle += this.sliceAngles[index];
                });
            }

            updateArcPaths() {
                const arcPaths = document.querySelectorAll('path[id^="arc"]');
                let currentAngle = 0;
                let arcIndex = 0;

                for (let sliceIndex = 0; sliceIndex < this.sliceCount; sliceIndex++) {
                    const sliceAngle = this.sliceAngles[sliceIndex];
                    const startAngle = currentAngle;
                    const endAngle = currentAngle + sliceAngle;

                    // Calculate how many arcs per slice (depends on max layers)
                    const arcsPerSlice = Math.floor(arcPaths.length / this.sliceCount);
                    for (let layerIndex = 0; layerIndex < arcsPerSlice; layerIndex++) {
                        if (arcIndex < arcPaths.length) {
                            const radius = 60 + layerIndex * 19.5;
                            const pathData = this.createArcPath(startAngle, endAngle, radius);
                            arcPaths[arcIndex].setAttribute('d', pathData);
                            arcIndex++;
                        }
                    }

                    currentAngle += sliceAngle;
                }
            }

            createSlicePath(startAngle, endAngle) {
                const startRad = (startAngle * Math.PI) / 180;
                const endRad = (endAngle * Math.PI) / 180;

                const x1 = this.centerX + this.radius * Math.cos(startRad);
                const y1 = this.centerY + this.radius * Math.sin(startRad);
                const x2 = this.centerX + this.radius * Math.cos(endRad);
                const y2 = this.centerY + this.radius * Math.sin(endRad);

                const largeArcFlag = endAngle - startAngle > 180 ? 1 : 0;

                return `M ${this.centerX},${this.centerY} L ${x1},${y1} A ${this.radius},${this.radius} 0 ${largeArcFlag},1 ${x2},${y2} Z`;
            }

            createArcPath(startAngle, endAngle, radius) {
                const startRad = (startAngle * Math.PI) / 180;
                const endRad = (endAngle * Math.PI) / 180;

                const x1 = this.centerX + radius * Math.cos(startRad);
                const y1 = this.centerY + radius * Math.sin(startRad);
                const x2 = this.centerX + radius * Math.cos(endRad);
                const y2 = this.centerY + radius * Math.sin(endRad);

                const largeArcFlag = endAngle - startAngle > 180 ? 1 : 0;

                return `M ${x1},${y1} A ${radius},${radius} 0 ${largeArcFlag},1 ${x2},${y2}`;
            }

            reset() {
                this.sliceAngles = Array(3).fill(120.0);
                this.updateAllSlices();
            }

            setupRotation() {
                const record = document.querySelector('.record');
                let rotation = 0;
                let isDragging = false;
                let startAngle = 0;
                let startRotation = 0;

                const getCenter = (el) => {
                    const rect = el.getBoundingClientRect();
                    return {
                        x: rect.left + rect.width / 2,
                        y: rect.top + rect.height / 2
                    };
                };

                const setTransform = () => {
                    record.setAttribute('transform', `rotate(${rotation} 200 200)`);
                };

                record.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('clickable-slice')) return;

                    isDragging = true;
                    const center = getCenter(record.closest('svg'));
                    startAngle = Math.atan2(e.clientY - center.y, e.clientX - center.x);
                    startRotation = rotation;
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;

                    const center = getCenter(record.closest('svg'));
                    const currentAngle = Math.atan2(e.clientY - center.y, e.clientX - center.x);
                    let angleDiff = currentAngle - startAngle;

                    if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                    rotation = startRotation + (angleDiff * 180 / Math.PI);
                    setTransform();
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });

                // Touch events
                record.addEventListener('touchstart', (e) => {
                    if (e.touches.length !== 1) return;

                    const touch = e.touches[0];
                    const target = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (target && target.classList.contains('clickable-slice')) return;

                    isDragging = true;
                    const center = getCenter(record.closest('svg'));
                    startAngle = Math.atan2(touch.clientY - center.y, touch.clientX - center.x);
                    startRotation = rotation;
                    e.preventDefault();
                });

                document.addEventListener('touchmove', (e) => {
                    if (!isDragging || e.touches.length !== 1) return;

                    const touch = e.touches[0];
                    const center = getCenter(record.closest('svg'));
                    const currentAngle = Math.atan2(touch.clientY - center.y, touch.clientX - center.x);
                    let angleDiff = currentAngle - startAngle;

                    if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                    rotation = startRotation + (angleDiff * 180 / Math.PI);
                    setTransform();
                    e.preventDefault();
                });

                document.addEventListener('touchend', () => {
                    isDragging = false;
                });
            }
        }

        // Initialize wheel
        const dialecticalWheel = new DialecticalWheel();

        // Global reset function
        function resetSlices() {
            dialecticalWheel.reset();
        }
    
    </script>
</body>
</html>